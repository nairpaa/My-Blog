[ { "title": "Web Reconnaissance & Enumeration Cheatsheet", "url": "/posts/web-recon-enum-cheatsheet/", "categories": "Web App Security, WebApp Techniques", "tags": "reconnaissance, enumeration, technology-detection, osint", "date": "2026-01-05 09:05:00 +0700", "content": "Introduction Reconnaissance and enumeration are the foundation of web application pentesting. Without thorough recon, we miss targets, waste time on irrelevant paths, and fail to map the complete attack surface. This cheatsheet covers essential techniques and tools for web reconnaissance and enumeration. Important: This cheatsheet provides baseline actions - manual analysis and verification are essential Tool versions may affect command syntax and output format - adjust accordingly Reconnaissance is not a one-size-fits-all process - adapt techniques to your specific target Think outside the box when standard methods fail This article is under active development and will be continuously updated Project Setup # Create project structure mkdir -p 2026/target.com &amp;&amp; cd 2026/target.com mkdir subdomains ports dirs ssl Root Domain Discovery cd subdomains # Find ASN by organization name amass intel -org \"Organization Name\" -o asn.txt # Alternative: https://bgp.he.net/ (manual, faster) # Find domains by ASN amass intel -asn \"AS12345\" -o asn-subnet.txt # Alternative: https://ipinfo.io/AS12345 (requires login) # Find ASN from domain dig +short target.com curl https://ipinfo.io/{ip}/json # WHOIS lookup whois target.com # Historical WHOIS: https://whois-history.whoisxmlapi.com/ Subdomain Enumeration domain='target.com' # OSINT discovery - subfinder subfinder -d \"$domain\" -o domain-ip-subfinder.txt -active -ip awk -F\",\" '{print $1}' domain-ip-subfinder.txt &gt; domain-subfinder.txt awk -F\",\" '{print $2}' domain-ip-subfinder.txt &gt; ip-subfinder.txt # OSINT discovery - amass amass enum -d \"$domain\" -active -oA domain-ip-amass sed 's/\\x1B\\[[0-9;]*[mK]//g' domain-ip-amass.txt | grep -Eo \"([a-zA-Z0-9_-]+\\.)+${domain}\" | sort -u &gt; domain-amass.txt grep -oE '([0-9]{1,3}\\.){3}[0-9]{1,3}' domain-ip-amass.txt | sort -u &gt; ip-amass.txt # Brute-force discovery gobuster dns --domain \"$domain\" \\ -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\ -o domain-ip-brute.txt --resolver 1.1.1.1 --delay 100ms --timeout 5s sed 's/\\x1B\\[[0-9;]*[mK]//g' domain-ip-brute.txt | awk '{print $1}' | sort -u &gt; domain-brute.txt # Merge results cat domain-amass.txt domain-brute.txt domain-subfinder.txt | sort -u &gt; all-subdomains.txt cat ip-amass.txt ip-brute.txt ip-subfinder.txt | sort -u &gt; all-ip.txt # Generate permutations dnsgen all-subdomains.txt &gt; permutations-temp.txt cat all-subdomains.txt permutations-temp.txt | sort -u &gt; permutations.txt rm permutations-temp.txt # Validate with DNS dnsx -l permutations.txt -o valid-subdomains.txt -stats -silent -r 1.1.1.1 echo \"$domain\" &gt;&gt; valid-subdomains.txt Port Scanning cd ../ports # Passive scanning (Shodan via nrich) cat ../subdomains/all-ip.txt | xargs -I{} -n1 sh -c 'echo {} | nrich -; sleep 2' &gt; shodan-ips.txt # Active scanning - naabu naabu -l ../subdomains/all-ip.txt -top-ports 100 -o naabu-ips.txt # Active scanning - nmap nmap -p- -oN {target}-allports.nmap {target} -vv nmap -sV -sC --script vuln -p{ports} -oN {target}.nmap {target} -vv Live Host Discovery # Probe subdomains cat ../subdomains/valid-subdomains.txt | httpx -o http.txt -title -status-code -tech-detect # Probe IPs cat ../subdomains/all-ip.txt | httpx -o http-ip.txt -title -status-code -tech-detect # Merge and screenshot cat http-ip.txt http.txt | sort -u &gt; http-all.txt awk '{print $1}' http-all.txt &gt; http-all-clean.txt gowitness scan file -f http-all-clean.txt WAF Detection cd ../dirs wafw00f https://target.com/ | tee waf.txt Finding origin IP behind WAF: Check DNS history: SecurityTrails Compare screenshots from Live Host Discovery Virtual host enumeration with ffuf + gowitness If found, test access: # Replace 203.0.113.50 with actual origin IP echo \"203.0.113.50 target.com\" | sudo tee -a /etc/hosts curl -i http://target.com Content Discovery # Passive discovery echo \"https://target.com\" | gau &gt; gau.txt echo \"https://target.com\" | waybackurls &gt; waybackurls.txt cat gau.txt waybackurls.txt | sort -u &gt; osint-url.txt # Active discovery - dirsearch dirsearch -u \"https://target.com/\" -o dirsearch.txt dirsearch -r -u \"https://target.com/\" -o dirsearch-recursive.txt # Active discovery - gobuster gobuster dir -u https://target.com/ -w /usr/share/dirb/wordlists/common.txt -o gobuster-common.txt gobuster dir -u https://target.com/ -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -o gobuster-raftdir.txt # Crawling - katana katana -d 4 -jc -u https://target.com -o katana.txt # Extract parameters cat osint-url.txt | grep \"=\" grep -oP '(?&lt;=\\?).*' osint-url.txt | tr '&amp;' '\\n' | cut -d= -f1 | sort -u &gt; parameters.txt # Parameter discovery paramspider -d target.com arjun -u https://target.com Browser Extensions Browser extensions can assist with reconnaissance directly from your browser while browsing the target application. Technology Detection: Wappalyzer - Identifies web technologies, frameworks, CMS, and server software Endpoint Discovery: Endpoint Extractor - Extracts API endpoints and paths from web pages Credential Leak Detection: TruffleHog Chrome Extension - Scans for exposed secrets and credentials in web content These extensions complement automated tools by providing real-time analysis during manual browsing. SSL/TLS Analysis cd ../ssl nmap --script \"ssl*\" -p443 -oN ssl.nmap target.com testssl.sh target.com | tee testssl.txt OSINT GitHub \"target.com\" \"target.com\" password \"target.com\" api_key \"target.com\" secret \"target.com\" path:**/.env \"target.com\" path:**/config \"target.com\" language:python password Shodan hostname:\"target.com\" ssl.cert.subject.cn:\"target.com\" http.title:\"target.com\" org:\"Organization Name\" net:\"203.0.113.0/24\" Google Dorking site:target.com site:*.target.com # Login pages site:target.com inurl:login site:target.com inurl:admin site:target.com intitle:admin # Sensitive files site:target.com filetype:pdf site:target.com filetype:sql site:target.com filetype:log site:target.com filetype:env site:target.com filetype:config # Sensitive directories site:target.com inurl:backup site:target.com inurl:api site:target.com inurl:test site:target.com inurl:dev # Credentials site:target.com intext:password site:target.com intext:username # Error messages site:target.com intext:\"sql syntax\" site:target.com intext:\"stack trace\" # Technology info site:target.com inurl:phpinfo site:target.com intext:\"powered by\" Bing site:target.com site:target.com filetype:pdf site:target.com instreamset:(url title):login Wayback Machine https://web.archive.org/web/*/target.com https://web.archive.org/web/*/subdomain.target.com Censys \"target.com\" host.services.dns.names: \"target.com\" host.services.http.response.html_title: \"App Name\" host.services.port = 443 and host.services.dns.names: \"target.com\" host.services.software.product: \"nginx\" Pastebin site:pastebin.com \"target.com\" site:ghostbin.com \"target.com\" Social Media \"target.com\" site:x.com \"target.com\" site:reddit.com Conclusion This cheatsheet covers essential reconnaissance techniques for web applications. Always combine automated tools with manual analysis for comprehensive results. Reconnaissance is not a one-size-fits-all process - adapt techniques based on target context and be creative in your approach. Think outside the box when standard methods don’t yield results. This article is still under development and will be updated with new techniques and tools." }, { "title": "Code Signing in Windows Applications", "url": "/posts/code-signing-in-windows-app/", "categories": "Windows App Security, WinApp Techniques", "tags": "enumeration, code-signing, certificate-analysis, windows", "date": "2026-01-04 21:46:00 +0700", "content": "Introduction Code signing is a security mechanism that uses digital signatures to verify the authenticity and integrity of executables. When an application is signed, any modification to the binary invalidates the signature. This article covers how to verify code signatures and demonstrates why signature validation matters in application security. Why Code Signing Matters Code signing serves two main purposes: Authenticity - Confirms the application comes from a verified publisher Integrity - Detects any tampering or modification to the executable Without proper code signing, attackers can: Modify legitimate applications without detection Distribute trojaned versions of software Bypass application whitelisting based on signatures Impersonate trusted software vendors During security assessments, unsigned applications or those using self-signed certificates in production environments should be reported as security findings. According to OWASP Desktop App Security Top 10, lack of proper code signing falls under DA8 - Poor Code Quality. File Types That Support Code Signing Code signing is not limited to executables. Various Windows file types can be digitally signed: .exe - Executable files .dll - Dynamic-link libraries .sys - System drivers .msi - Windows Installer packages .cab - Cabinet archive files .ocx - ActiveX controls .ps1 - PowerShell scripts and more This article demonstrates code signing using .exe files, but the same principles apply to other file types. Demonstration: Signature Verification We’ll demonstrate how code signing works and how it detects tampering. Step 1: Create Unsigned Application Create a simple C++ application: #include int main() { std::cout &lt;&lt; \"Hello World!\\n\"; } Build it as x64 Release in Visual Studio. Visual Studio code The executable will be at x64\\Release\\HelloWorld.exe. Step 2: Verify Signature Status Using Windows Properties: Right-click the executable → Properties → Digital Signatures tab Unsigned application - Digital Signatures tab is empty Using sigcheck: Use sigcheck from Sysinternals: PS &gt; .\\HelloWorld.exe Hello World! PS &gt; sigcheck .\\HelloWorld.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld.exe: Verified: Unsigned Link date: 07:56 04/01/2026 Publisher: n/a Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit Result: The application is Unsigned - anyone can modify it without detection. Step 3: Create Self-Signed Certificate For testing, we’ll create a self-signed certificate. Production environments should use trusted Certificate Authorities like DigiCert, Sectigo, or GlobalSign. # Create certificate $cert = New-SelfSignedCertificate ` -Subject \"CN=Lab Code Signing Certificate\" ` -Type CodeSigningCert ` -CertStoreLocation \"Cert:\\CurrentUser\\My\" ` -NotAfter (Get-Date).AddYears(1) # Export to PFX file $password = ConvertTo-SecureString -String \"LabPassword123\" -Force -AsPlainText Export-PfxCertificate ` -Cert $cert ` -FilePath \"C:\\path\\to\\codesign.pfx\" ` -Password $password Step 4: Sign the Application Use signtool (included in Windows SDK): signtool sign /f codesign.pfx /p LabPassword123 /fd SHA256 HelloWorld.exe Using Windows Properties: Right-click the signed executable → Properties → Digital Signatures tab Signed application - Digital Signatures tab shows certificate details Using sigcheck: PS &gt; sigcheck .\\HelloWorld.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld.exe: Verified: A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider. Link date: 07:56 04/01/2026 Publisher: Lab Code Signing Certificate Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit The application is signed but shows a warning because the certificate isn’t trusted. This is expected for self-signed certificates. Step 5: Trust the Certificate (Testing Only) To simulate a trusted signature, import the certificate to the Trusted Root store: # Run as Administrator PS &gt; Import-PfxCertificate ` -FilePath \"C:\\path\\to\\codesign.pfx\" ` -CertStoreLocation Cert:\\LocalMachine\\Root ` -Password (ConvertTo-SecureString -String \"LabPassword123\" -AsPlainText -Force) PSParentPath: Microsoft.PowerShell.Security\\Certificate::LocalMachine\\Root Thumbprint Subject ---------- ------- 37EC816665AC772A6375F6DD87AA2ED4B84093C5 CN=Lab Code Signing Certificate Verify again: PS &gt; sigcheck .\\HelloWorld.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld.exe: Verified: Signed Signing date: 08:08 04/01/2026 Publisher: Lab Code Signing Certificate Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit Now the signature is Verified: Signed. Step 6: Test Tampering Detection Let’s modify the signed binary to demonstrate signature validation: Open HelloWorld.exe in Ghidra Locate the “Hello World!” string Change it to “HACKED!!!!!!” Export as HelloWorld-patched.exe Original “Hello World!” string Patched to “HACKED!!!!!!” Run and verify the patched binary: PS &gt; .\\HelloWorld-patched.exe HACKED!!!!!! PS &gt; sigcheck .\\HelloWorld-patched.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld-patched.exe: Verified: The digital signature of the object did not verify. Signing date: 09:38 04/01/2026 Publisher: Lab Code Signing Certificate Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit Result: The digital signature of the object did not verify. Even a small modification invalidates the signature, preventing undetected tampering. Conclusion Code signing protects applications from tampering by verifying authenticity and integrity. During security assessments, unsigned applications or those with self-signed certificates in production should be reported as findings. Always verify signatures when pentesting Windows applications to identify potential security gaps." }, { "title": "Identifying Technology Stack in Windows Applications", "url": "/posts/identify-tech-stack-in-windows-app/", "categories": "Windows App Security, WinApp Techniques", "tags": "enumeration, technology-detection, pe-analysis, windows", "date": "2026-01-02 17:04:00 +0700", "content": "Introduction The first step in pentesting a Windows application is understanding what technology it’s built with. This determines our entire testing approach. This article covers essential techniques for identifying the technology stack of Windows executables. Why Technology Detection Matters Different technologies have different attack surfaces. For example: .NET applications → Easy to decompile with dnSpy Native C/C++ → Memory corruption vulnerabilities like buffer overflows Electron apps → Node.js vulnerabilities and XSS in webviews Delphi/VB → Require specific decompilers, often have legacy vulnerabilities Packed/Protected → Must be unpacked before analysis Knowing the technology helps us choose the right testing approach and exploitation techniques. Detection Tools Detect It Easy (DiE) DiE is the tool I usually use first when analyzing Windows executables. It’s open-source and available on GitHub. How to use: Download and extract DiE from the releases page Run die.exe Open the executable you want to analyze (File → Open or drag and drop) DiE will automatically show the detection results As an example, let’s analyze Notepad from C:\\Windows\\notepad.exe: Compiler: Microsoft Visual C/C++(19.36.33145)[LTCG/C] Linker: Microsoft Linker(14.36.33145) Language: C++ Tool: Visual Studio(2022, v17.6) From the results, we can see that Notepad is a native C++ application compiled with Visual Studio 2022. Additional samples to try: If you want to practice identifying different technologies, here are some executables you can download: Technology Application Description Go Hugo Static compiled Go binary Delphi/Pascal Cheat Engine Delphi GUI application Electron VS Code Electron-based editor with JavaScript/TypeScript .NET dnSpy .NET Framework application Packed (UPX) UPX Self-packed executable Rust Alacritty Terminal emulator written in Rust Alternative Tools CFF Explorer - PE structure analysis tool, closed-source, last updated 2012 (ntcore.com) PEiD - Classic packer/compiler detector (no longer maintained) strings - Extract readable strings from binaries (Sysinternals) Conclusion Identifying the technology stack is essential before pentesting any Windows application. Different technologies require different approaches. Know the technology, choose the right tools, find the vulnerabilities." } ]
